using HaProxyApi.Models;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace HaProxyApi.Parser
{
	/// <summary>
	/// Analiza la respuesta del comando Show Info y la convierte a un modelo.
	/// </summary>
	/// <autogeneratedoc />
	public class ShowInfoParser
	{
		public IShowInfoResponse Parse(string rawShowInfoResult)
		{
			var propertyDictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

			if (!string.IsNullOrEmpty(rawShowInfoResult))
			{
				var matchResult = Regex.Matches(rawShowInfoResult, @"(?<key>[\w-]+): (?<value>.+)$", RegexOptions.Multiline);

				if (matchResult.Count != 0)
				{
					foreach (Match match in matchResult)
					{
						if (!match.Success) continue;
						propertyDictionary[match.Groups["key"].Value] = match.Groups["value"].Value;
					}
				}
			}
			return GetResult(rawShowInfoResult, propertyDictionary);
		}

		/// <summary>
		/// Auxiliar 
		/// </summary>
		/// <param name="raw"></param>
		/// <param name="properties"></param>
		/// <returns></returns>
		protected virtual ShowInfoResponse GetResult(string raw, Dictionary<string, string> properties)
		{
			if (string.IsNullOrWhiteSpace(raw) || properties == null || !properties.Any())
				return new ShowInfoResponse()
				{
					Raw = raw
				};
			return new ShowInfoResponse()
			{
				Name = GetValue<string>(properties, "Name"),
				Version = GetValue<string>(properties, "Version"),
				MaxConnections = GetValue<int>(properties, "Maxconn"),
				ReleaseDate = GetDateTime(properties, "Release_date"),
				MaxSockets = GetValue<int>(properties, "Maxsock"),
				Uptime = TimeSpan.FromSeconds(GetValue<int>(properties, "Uptime_sec")),
				Node = GetValue<string>(properties, "node"),
				UlimitN = GetValue<int>(properties, "Ulimit-n")
			};
		}

		/// <summary>
		/// Gets the value.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="properties">The properties.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		private T GetValue<T>(Dictionary<string, string> properties, string propertyName)
		{
			if (!properties.ContainsKey(propertyName))
				return default(T);

			return (T)Convert.ChangeType(properties[propertyName], typeof(T));
		}

		/// <summary>
		/// Obtener la fecha y hora en formato cadena y convertirlo a DataTime
		/// </summary>
		/// <param name="properties">Lista de propiedades del objeto</param>
		/// <param name="propertyName">Nombre del objeto a obtener</param>
		/// <returns></returns>
		/// <autogeneratedoc />
		private DateTime? GetDateTime(Dictionary<string, string> properties, string propertyName)
        {

            DateTime? getDateTime(string value, string format)
            {
                DateTime dateTime;
                if (DateTime.TryParseExact(properties[propertyName], format, CultureInfo.InvariantCulture,
                    DateTimeStyles.None, out dateTime))
                {
                    return dateTime; }

                return null;
            }

			string dateFormat = "yyyy/MM/dd";

			if (!properties.ContainsKey(propertyName))
				return null;
            return DateTime.ParseExact(properties[propertyName], dateFormat, CultureInfo.InvariantCulture);



			

			
		}
	}

}
